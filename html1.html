<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3-Stage Canvas Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            border: 4px solid #fff;
            background-color: #000;
            image-rendering: pixelated; /* Keeps pixel art crisp */
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
/**
 * 1. ASSET LOADER SYSTEM
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GAME_WIDTH = canvas.width;
const GAME_HEIGHT = canvas.height;

// Input Handling
const keys = {};
const keyPresses = {}; 
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (!e.repeat) keyPresses[e.code] = true; 
});
window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    keyPresses[e.code] = false;
});

// IMAGE DATABASE
const images = {}; 

// TODO: Ensure these files exist in your folder
const imageSources = {
    player: 'frenchfry.webp',
    enemy: 'enemy.png',
    startScreen: 'title_screen.png',   
    level1Bg: 'forest.png',            
    level2Bg: 'loading2nd.png',            
    level3Bg: 'sky.png',
    ending: 'endingscreen.jpg',
    wasted: 'wasted.png'
};

function loadAssets(callback) {
    let loadedCount = 0;
    const totalImages = Object.keys(imageSources).length;
    
    if (totalImages === 0) {
        callback(); 
        return;
    }

    for (let key in imageSources) {
        const img = new Image();
        img.src = imageSources[key];
        img.onload = () => {
            loadedCount++;
            if (loadedCount >= totalImages) callback();
        };
        img.onerror = () => {
            // Fallback: Continue even if image is missing
            loadedCount++; 
            if (loadedCount >= totalImages) callback();
        };
        images[key] = img; 
    }
}

function drawGTAText(ctx, text, x, y, size, align = 'left') {
    ctx.save();
    ctx.textAlign = align;
    // GTA Style: Italic Impact font, Black outline, Gold fill
    ctx.font = "italic " + size + "px Impact, sans-serif";
    ctx.lineWidth = Math.max(2, size / 12);
    ctx.strokeStyle = 'black';
    ctx.strokeText(text, x, y);
    ctx.fillStyle = '#bfa55a';
    ctx.fillText(text, x, y);
    ctx.restore();
}

class TransitionScreen {
    constructor(manager, nextLevelKey, text, bgImageName) {
        this.manager = manager;
        this.nextLevelKey = nextLevelKey;
        this.text = text;
        this.bgImageName = bgImageName;
        // this.timer = 180; // Removed auto-timer
    }

    update() {
        // Only advance when Enter is pressed
        if (keyPresses['Enter']) {
            this.manager.changeScene(this.nextLevelKey);
        }
    }

    draw(ctx) {
        // Draw Background Image (if it exists)
        const img = images[this.bgImageName];
        if (img && img.complete && img.naturalWidth !== 0) {
            ctx.drawImage(img, 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            // Fallback Black Screen
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        // Draw Text
        drawGTAText(ctx, this.text, GAME_WIDTH / 2, GAME_HEIGHT / 2, 40, 'center');
        drawGTAText(ctx, "Press ENTER to Continue...", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50, 24, 'center');
    }
}

class GameOverScreen {
    constructor(manager, retryLevelKey) {
        this.manager = manager;
        this.retryLevelKey = retryLevelKey;
    }

    update() {
        if (keyPresses['Enter']) {
            this.manager.changeScene(this.retryLevelKey);
        }
    }

    draw(ctx) {
        if (images['wasted'] && images['wasted'].complete && images['wasted'].naturalWidth !== 0) {
            ctx.drawImage(images['wasted'], 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            // Fallback
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            drawGTAText(ctx, "WASTED", GAME_WIDTH / 2, GAME_HEIGHT / 2, 60, 'center');
        }
        
        drawGTAText(ctx, "Press ENTER to Retry", GAME_WIDTH / 2, GAME_HEIGHT - 50, 30, 'center');
    }
}
/**
 * 2. SCENE MANAGER
 */
class SceneManager {
    constructor() {
        this.currentScene = new StartScreen(this); 
    }

    changeScene(sceneType, params) {
        // Reset Inputs
        for (let key in keys) delete keys[key]; 
        
        switch(sceneType) {
            case 'level1':
                this.currentScene = new Level1(this);
                break;
                
            // NEW: Transition to Level 2
            case 'transition_to_level2':
                // (Manager, NextScene, TextToDisplay, ImageKey)
                this.currentScene = new TransitionScreen(this, 'level2', 'STAGE 2: THE CHASE', 'level2Bg'); 
                break;
                
            case 'level2':
                this.currentScene = new Level2(this);
                break;

            // NEW: Transition to Level 3
            case 'transition_to_level3':
                this.currentScene = new TransitionScreen(this, 'level3', 'STAGE 3: THE TRAPEZE', 'level3Bg');
                break;

            case 'level3':
                this.currentScene = new Level3(this);
                break;

            case 'end':
                this.currentScene = new EndScreen(this);
                break;

            case 'game_over':
                this.currentScene = new GameOverScreen(this, params);
                break;
        }
    }

    update() {
        this.currentScene.update();
    }

    draw(ctx) {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        this.currentScene.draw(ctx);
    }
}

/**
 * START SCREEN
 */
class StartScreen {
    constructor(manager) {
        this.manager = manager;
    }
    
    update() {
        if (keyPresses['Enter']) {
            this.manager.changeScene('level1');
        }
    }

    draw(ctx) {
        // Background
        if (images['startScreen'] && images['startScreen'].complete && images['startScreen'].naturalWidth !== 0) {
            ctx.drawImage(images['startScreen'], 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        drawGTAText(ctx, "MY 3-STAGE ADVENTURE", GAME_WIDTH / 2, 200, 50, 'center');
        drawGTAText(ctx, "Press ENTER to Start", GAME_WIDTH / 2, 400, 30, 'center');
    }
}

/**
 * LEVEL 1: BEAT 'EM UP
 */
class Level1 {
    constructor(manager) {
        this.manager = manager;

        // --- PLAYER CONFIG ---
        this.player = {
            x: 100, y: 300,
            width: 60, height: 120,
            speed: 8,
            color: '#FFD700', // French Fry Yellow
            facing: 1,
            isAttacking: false,
            attackCooldown: 0,
            hp: 8,            // Set to 8 hits
            invulnTimer: 0    // Invulnerability frames after getting hit
        };

        this.enemiesDefeated = 0;
        this.enemiesToClear = 20;
        
        // --- BOSS STATE ---
        this.bossSpawned = false;
        this.bossDefeated = false;
        this.bossDeathTimer = 0; // Timer for post-death delay
        this.warningTimer = 0;
        this.screenShake = 0;

        this.enemies = [];
        this.projectiles = []; // Boss Projectiles

        // Visual FX Arrays
        this.particles = [];
        this.decals = []; // Stains on the ground

        for (let i = 0; i < 4; i++) {
            this.spawnEnemy();
        }
    }

    spawnEnemy() {
        this.enemies.push({
            x: GAME_WIDTH + 50,
            y: Math.random() * (GAME_HEIGHT - 100) + 50,
            width: 40, height: 80,
            speed: 2 + Math.random(),
            color: '#e63946',
            hp: 3,
            state: 'chasing',
            hurtTimer: 0,
            isBoss: false
        });
    }

    spawnBoss() {
        this.enemies.push({
            x: GAME_WIDTH + 150, // Spawn off-screen
            y: GAME_HEIGHT / 2 - 80,
            width: 80, height: 160, // 2x Size
            speed: 3,
            color: '#800f2f', // Darker Boss Color
            hp: 9, // 3x HP
            state: 'chasing',
            hurtTimer: 0,
            attackTimer: 0,
            isBoss: true
        });
    }

    // Helper to create splatter effects
    spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10, // Random horizontal scatter
                vy: (Math.random() - 0.5) * 10, // Random vertical scatter
                life: 30, // How many frames it lasts
                color: color,
                size: Math.random() * 5 + 2
            });
        }
    }

    // Helper to add permanent stains to the floor
    addDecal(x, y, color) {
        this.decals.push({
            x: x,
            y: y + 30, // Offset to be near feet
            width: Math.random() * 20 + 10,
            height: Math.random() * 10 + 5,
            color: color
        });
    }

    update() {
        // --- SCREEN SHAKE DECAY ---
        if (this.screenShake > 0) this.screenShake--;

        // --- PLAYER MOVEMENT ---
        if (keys['ArrowLeft']) { this.player.x -= this.player.speed; this.player.facing = -1; }
        if (keys['ArrowRight']) { this.player.x += this.player.speed; this.player.facing = 1; }
        if (keys['ArrowUp'] && this.player.y > 150) this.player.y -= this.player.speed;
        if (keys['ArrowDown'] && this.player.y < GAME_HEIGHT - this.player.height) this.player.y += this.player.speed;

        // --- PLAYER COMBAT TIMERS ---
        if (this.player.attackCooldown > 0) this.player.attackCooldown--;
        if (this.player.invulnTimer > 0) this.player.invulnTimer--; // Count down invulnerability

        // --- PLAYER ATTACK LOGIC ---
        let playerHitbox = {
             x: this.player.facing === 1 ? this.player.x + this.player.width : this.player.x - 80,
             y: this.player.y + 20, 
             width: 80, height: 80 
        };

        if (keyPresses['Space'] && this.player.attackCooldown <= 0) {
            this.player.isAttacking = true;
            this.player.attackCooldown = 20;

            this.enemies.forEach(enemy => {
                if (this.checkCollision(playerHitbox, enemy)) {
                    enemy.hp--;
                    enemy.state = 'hurt';
                    enemy.hurtTimer = 15;
                    enemy.x += (20 * this.player.facing); // Knockback
                    if (enemy.isBoss) enemy.x += (5 * this.player.facing); // Less knockback for boss

                    // FX: Enemy bleeds Ketchup
                    this.spawnParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#cc0000', 8);
                    this.addDecal(enemy.x, enemy.y + enemy.height, '#880000');
                }
            });
            keyPresses['Space'] = false;
        } else {
            this.player.isAttacking = false;
        }

        // --- PROJECTILE LOGIC (BOSS) ---
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            let proj = this.projectiles[i];
            proj.x += proj.vx;
            proj.y += proj.vy;

            // 1. Remove if off-screen
            if (proj.x < -50 || proj.x > GAME_WIDTH + 50 || proj.y < -50 || proj.y > GAME_HEIGHT + 50) {
                this.projectiles.splice(i, 1);
                continue;
            }

            // 2. Check Collision with Player Attack (Reflection)
            // If player is attacking AND projectile is in the attack box
            if (this.player.isAttacking && this.checkCollision(playerHitbox, proj)) {
                if (!proj.reflected) {
                     proj.reflected = true;
                     proj.vx = -proj.vx * 1.5; // Reflect back faster!
                     proj.vy = -proj.vy;
                     proj.color = '#fff'; // Turn white to show it's friendly now
                     this.screenShake = 5; // Small impact shake
                     continue; // Skip damage check
                }
            }

            // 3. Check Collision with Player (Damage)
            if (!proj.reflected && this.checkCollision(proj, this.player)) {
                 if (this.player.invulnTimer <= 0) {
                     this.player.hp--;
                     this.player.invulnTimer = 60;
                     this.screenShake = 10;
                     this.spawnParticles(this.player.x, this.player.y, '#FFD700', 10);
                     this.projectiles.splice(i, 1);
                     
                     if (this.player.hp <= 0) this.manager.changeScene('game_over', 'level1');
                 }
                 continue;
            }
            
            // 4. Check Collision with Boss (Reflected Damage)
            if (proj.reflected) {
                 // Find the boss (assuming only one boss)
                 let boss = this.enemies.find(e => e.isBoss);
                 if (boss && this.checkCollision(proj, boss)) {
                      boss.hp--;
                      boss.state = 'hurt';
                      boss.hurtTimer = 15;
                      this.spawnParticles(boss.x + boss.width/2, boss.y + boss.height/2, '#cc0000', 15);
                      this.projectiles.splice(i, 1);
                      continue;
                 }
            }
        }

        // --- PARTICLE UPDATE ---
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        // --- ENEMY LOGIC ---
        this.enemies.forEach((enemy, index) => {
            // 1. Check Death
            if (enemy.hp <= 0) {
                this.enemies.splice(index, 1);
                
                if (enemy.isBoss) {
                    // Boss Defeated Logic
                    this.bossDefeated = true;
                    this.bossDeathTimer = 180; // 3 seconds delay
                    this.spawnParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#cc0000', 100); // BIG EXPLOSION
                    this.screenShake = 60; // Victory Shake
                } else {
                    // Regular Enemy Defeated
                    this.enemiesDefeated++;
                    this.spawnParticles(enemy.x, enemy.y, '#cc0000', 20);
                    
                    // Only spawn new regular enemies if boss hasn't started
                    if (this.enemiesDefeated < this.enemiesToClear) {
                        this.spawnEnemy();
                    }
                }
                return;
            }

            // 2. Handle Stun/Hurt State
            if (enemy.state === 'hurt') {
                enemy.hurtTimer--;
                if (enemy.hurtTimer <= 0) enemy.state = 'chasing';
                return;
            }

            // 3. Movement
            if (enemy.isBoss) {
                 // Boss Logic: Stay on right side, follow player Y
                const targetX = GAME_WIDTH - 200;
                
                // Horizontal Move (Rubber band to right side)
                const dx = targetX - enemy.x;
                enemy.x += dx * 0.05; 
                
                // Vertical Move (Chase Player)
                const dy = this.player.y - enemy.y;
                enemy.y += dy * 0.05;

                // BOSS ATTACK LOGIC
                if (!enemy.attackTimer) enemy.attackTimer = 0;
                enemy.attackTimer++;
                
                if (enemy.attackTimer > 120) { // Shoot every 2 seconds
                     enemy.attackTimer = 0;
                     
                     // Calculate direction to player
                     let pdx = (this.player.x + this.player.width/2) - (enemy.x + enemy.width/2);
                     let pdy = (this.player.y + this.player.height/2) - (enemy.y + enemy.height/2);
                     let dist = Math.sqrt(pdx*pdx + pdy*pdy);
                     
                     this.projectiles.push({
                         x: enemy.x,
                         y: enemy.y + 40,
                         width: 20, height: 20,
                         vx: (pdx / dist) * 6,
                         vy: (pdy / dist) * 6,
                         color: '#ff0000', // Ketchup Red
                         reflected: false
                     });
                }

            } else {
                // Regular Chasing
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 10) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
            }

            // 4. DEAL DAMAGE TO PLAYER
            if (this.checkCollision(enemy, this.player) && this.player.invulnTimer <= 0) {
                this.player.hp--;
                this.player.invulnTimer = 60; // 1 second of invincibility
                this.screenShake = 10;
                
                // FX: Player bleeds Yellow (French Fry bits)
                this.spawnParticles(this.player.x + 20, this.player.y + 40, '#FFD700', 10);
                
                // Slight knockback for player
                const knockDir = enemy.x < this.player.x ? 1 : -1;
                this.player.x += 20 * knockDir;
                
                if (this.player.hp <= 0) {
                    this.manager.changeScene('game_over', 'level1');
                }
            }
        });

        // --- LEVEL TRANSITION & BOSS SEQUENCE ---
        if (this.enemiesDefeated >= this.enemiesToClear && this.enemies.length === 0) {
            
            // Phase 1: Trgger Warning if not done yet
            if (!this.bossSpawned) {
                if (this.warningTimer === 0) {
                    this.warningTimer = 180; // 3 Seconds Warning
                    this.screenShake = 180;  // Shake during warning
                }
                
                this.warningTimer--;
                
                if (this.warningTimer <= 0) {
                    this.spawnBoss();
                    this.bossSpawned = true;
                    this.screenShake = 40; // Heavy Thud
                }
                return; // Do not transition, wait for boss
            }

            // Phase 2: Boss is Dead
            if (this.bossSpawned && this.bossDefeated) {
                this.bossDeathTimer--;
                if (this.bossDeathTimer <= 0) {
                     this.manager.changeScene('transition_to_level2');
                }
            }
        }

        // Debug skip
        if (keys['Enter']) this.manager.changeScene('level2');
    }

    draw(ctx) {
        ctx.save();
        
        // --- APPLY SCREEN SHAKE ---
        if (this.screenShake > 0) {
            const dx = (Math.random() - 0.5) * 15;
            const dy = (Math.random() - 0.5) * 15;
            ctx.translate(dx, dy);
        }

        // 1. Background
        if (images['level1Bg'] && images['level1Bg'].complete && images['level1Bg'].naturalWidth !== 0) {
            ctx.drawImage(images['level1Bg'], 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            ctx.fillStyle = '#444';
            ctx.fillRect(0, 0, GAME_WIDTH, 150);
            ctx.fillStyle = '#2d6a4f';
            ctx.fillRect(0, 150, GAME_WIDTH, GAME_HEIGHT - 150);
        }

        // 2. Draw Decals (Blood/Ketchup stains on ground) - BEHIND characters
        this.decals.forEach(d => {
            ctx.fillStyle = d.color;
            // PIXELATED LOOK: Draw a rectangle instead of a smooth ellipse
            ctx.fillRect(d.x - d.width / 2, d.y - d.height / 4, d.width, d.height / 2);
        });

        // 3. UI
        if (!this.bossSpawned) {
            drawGTAText(ctx, `Defeated: ${this.enemiesDefeated}/${this.enemiesToClear}`, 20, 30, 24);
        } else {
            drawGTAText(ctx, `BOSS FIGHT`, 20, 30, 24, 'left');
        }
        
        // HP Display
        drawGTAText(ctx, `HP:`, 20, 60, 24);
        for(let i = 0; i < 8; i++) {
            ctx.fillStyle = i < this.player.hp ? 'lime' : 'gray';
            ctx.fillRect(60 + (i * 25), 45, 20, 15);
        }

        // 4. Z-Sorting (Entities)
        const renderList = [
            { ...this.player, type: 'player', ref: this.player }, 
            ...this.enemies.map(e => ({ ...e, type: 'enemy' }))
        ];

        renderList.sort((a, b) => (a.y + a.height) - (b.y + b.height));

        renderList.forEach(entity => {
            if (entity.type === 'player') {
                // --- PLAYER DRAWING ---

                // 1. Invulnerability Flash
                if (this.player.invulnTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // 2. Setup Drawing Context (Flip Logic)
                if (images['player'] && images['player'].complete) {
                    ctx.save();
                    
                    // Move pivot to center of player
                    ctx.translate(entity.x + entity.width / 2, entity.y + entity.height / 2);
                    
                    // Flip logic: if facing is -1, it mirrors horizontally
                    ctx.scale(entity.facing, 1); 
                    
                    // Draw Player Image centered at (0,0)
                    ctx.drawImage(images['player'], -entity.width / 2, -entity.height / 2, entity.width, entity.height);

                    // 3. Punch Animation (Extension of texture)
                    // If attacking, draw a "fist" extending from the body
                    if (entity.isAttacking) {
                        ctx.fillStyle = entity.color; // Same color as fry
                        // Draw a fist block slightly in front
                        // Coordinates are relative to the center and are automatically flipped by scale()
                        ctx.fillRect(entity.width / 2 - 5, -5, 30, 20); 
                    }

                    ctx.restore();
                } else {
                    // Fallback to Box if image missing
                    ctx.fillStyle = entity.color;
                    ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                    
                    // Fallback Attack Box
                    if (entity.isAttacking) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        let attackX = entity.facing === 1 ? entity.x + entity.width : entity.x - 40;
                        ctx.fillRect(attackX, entity.y + 20, 40, 40);
                    }
                }
                
                ctx.globalAlpha = 1.0; // Reset alpha

            } else {
                // --- ENEMY DRAWING LOGIC ---
                if (entity.state === 'hurt') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                } 
                else if (images['enemy'] && images['enemy'].complete) {
                    ctx.drawImage(images['enemy'], entity.x, entity.y, entity.width, entity.height);
                } 
                else {
                    ctx.fillStyle = entity.color;
                    ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                }
            }
        });

        // 5. Draw Projectiles
        this.projectiles.forEach(p => {
             ctx.fillStyle = p.color;
             ctx.fillRect(p.x, p.y, p.width, p.height);
        });

        // 6. Draw Particles
        this.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });

        // 7. WARNING OVERLAY
        if (this.warningTimer > 0) {
            // Blink effect
            if (Math.floor(Date.now() / 200) % 2 === 0) {
                 drawGTAText(ctx, "WARNING", GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50, 80, 'center');
                 drawGTAText(ctx, "BOSS APPROACHING", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50, 50, 'center');
            }
        }
        
        ctx.restore(); // Restore Shake
    }

    checkCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y);
    }
}
/**
 * LEVEL 2: CHASE
 */

class Level2 {
    constructor(manager) {
        this.manager = manager;
        
        // --- PLAYER ---
        this.player = {
            x: 200, 
            y: 300,
            width: 80, height: 40,
            speed: 8,  
            color: '#ff006e', 
            hp: 8, 
            invincibleTimer: 0,
            blinkRate: 0
        };

        // --- CHASER ---
        this.chaser = {
            x: 50, 
            y: 300,
            width: 80, height: 40,
            color: '#ff0000', 
            lag: 15,
            crashed: false
        };
        this.playerTrail = [];

        this.gameSpeed = 7; 
        this.obstaclesAvoided = 0;
        this.goal = 30; // Reduced to 30
        
        this.obstacles = [];
        this.spawnTimer = 0;
        this.roadOffset = 0; 

        // --- BACKGROUND & LIGHTS SYSTEM ---
        this.bgElements = [];
        this.lights = [];
        
        // Initial Population
        for(let i=0; i<10; i++) {
            this.spawnBuilding(i * 100);
            if(i % 3 === 0) this.spawnLight(i * 300);
        }
        
        // --- CINEMATIC ENDING ---
        this.levelComplete = false;
        this.cinematicTimer = 0;
        this.stoppedAtCliff = false;
        this.cliffWaitTimer = 0;
        this.roadEndX = null; // Will define where the road visually ends
        this.particles = [];
    }

    spawnBuilding(xOffset) {
        let width = 60 + Math.random() * 60;
        let height = 100 + Math.random() * 150;
        this.bgElements.push({
            x: xOffset || GAME_WIDTH,
            y: 150 - height, // Ground level is at y=150
            width: width,
            height: height,
            color: Math.random() < 0.5 ? '#1a1a2e' : '#16213e', // Dark Blue/Grey hues
            windows: this.generateWindows(width, height)
        });
    }

    generateWindows(w, h) {
        let wins = [];
        let rows = Math.floor(h / 30);
        let cols = Math.floor(w / 20);
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                if(Math.random() > 0.3) { // 70% chance of a window
                    wins.push({
                        x: 5 + c * 15,
                        y: 10 + r * 25,
                        w: 8, h: 12,
                        lit: Math.random() > 0.5 // 50% chance light is on
                    });
                }
            }
        }
        return wins;
    }

    spawnLight(xOffset) {
        this.bgElements.push({
            type: 'light',
            x: xOffset || GAME_WIDTH,
            y: 50, // Top of pole
            h: 100 // Height to reach ground at 150
        });
    }

    // Helper to create particles (for explosion)
    spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10, 
                vy: (Math.random() - 0.5) * 10, 
                life: 60, 
                color: color,
                size: Math.random() * 5 + 3
            });
        }
    }

    update() {
        // 0. Dynamic Speed Increase (Stops updating if level complete)
        let speedMultiplier = this.obstaclesAvoided / this.goal;
        if (!this.levelComplete) {
            this.gameSpeed = 7 + (speedMultiplier * 18); 
        }

        // --- BACKGROUND UPDATE ---
        // Move Buildings (Parallax: 0.5x speed)
        this.bgElements.forEach(bg => {
            bg.x -= this.gameSpeed * 0.5;
        });
        
        // Spawn new buildings (Only if level not complete)
        let lastBg = this.bgElements[this.bgElements.length - 1];
        
        // Use a much larger spawn threshold if level is complete to stop spawning but keep array valid
        let spawnThreshold = this.levelComplete ? -99999 : GAME_WIDTH;

        if (!lastBg || lastBg.x + lastBg.width < spawnThreshold) {
             // Gap between buildings
             let spawnX = GAME_WIDTH;
             if (lastBg) spawnX = GAME_WIDTH + 20; 

             if(Math.random() < 0.1) {
                 this.spawnBuilding(spawnX + 20);
             } else {
                 this.spawnBuilding(spawnX);
             }
             
             if(Math.random() < 0.3) {
                 this.spawnLight(spawnX + 50);
             }
        }

        // Remove off-screen
        this.bgElements = this.bgElements.filter(bg => bg.x + (bg.width || 20) > -100);


        // 1. Player Movement
        if (keys['ArrowUp'] && this.player.y > 150) this.player.y -= this.player.speed;
        if (keys['ArrowDown'] && this.player.y < GAME_HEIGHT - 50 - this.player.height) this.player.y += this.player.speed;

        // 2. Chaser Logic
        this.playerTrail.push(this.player.y);
        if (this.playerTrail.length > this.chaser.lag) {
            if (!this.chaser.crashed) {
                this.chaser.y = this.playerTrail.shift(); 
            } else {
                this.playerTrail.shift(); // Keep cleaning up array
            }
        } else {
            if (!this.chaser.crashed) this.chaser.y = this.player.y; 
        }

        // 3. Road & Spawning
        this.roadOffset -= this.gameSpeed;
        if (this.roadOffset <= -100) this.roadOffset = 0;

        if (!this.levelComplete) {
            this.spawnTimer++;
            if (this.spawnTimer > 60) {
                this.spawnObstacle();
                this.spawnTimer = 0;
            }
        }

        // 4. Obstacle Logic
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let obs = this.obstacles[i];
            obs.x -= this.gameSpeed;

            if (this.player.invincibleTimer <= 0 && this.checkCollision(this.player, obs)) {
                this.player.hp--;
                this.player.invincibleTimer = 60; 
                this.obstacles.splice(i, 1); 
                continue;
            }

            if (obs.x + obs.width < 0) {
                this.obstacles.splice(i, 1);
                this.obstaclesAvoided++;
            }
        }

        // 5. Invincibility
        if (this.player.invincibleTimer > 0) {
            this.player.invincibleTimer--;
            this.player.blinkRate++;
        }

        // 6. Game State Checks
        if (!this.levelComplete && this.obstaclesAvoided >= this.goal) {
            this.levelComplete = true;
            this.roadEndX = GAME_WIDTH + 1200; // Start road end off-screen (further back to allow crash anim)
        }
        
        if (this.player.hp <= 0) {
            this.manager.changeScene('game_over', 'level2'); 
        }
        
        // --- CINEMATIC LOGIC ---
        if (this.levelComplete) {
            this.cinematicTimer++;
            
            // Move road end closer
            // We want to stop roughly when the road end is a bit ahead of the player
            // Player X is ~200. Width 80. Front is 280.
            // Let's stop when roadEnd is at 350.
            if (this.roadEndX > 350) {
                this.roadEndX -= this.gameSpeed;
            } else {
                // STOP THE WORLD
                this.gameSpeed = 0; 
                this.stoppedAtCliff = true;
            }

            // Chaser Crash Sequence
            if (this.cinematicTimer === 30) {
                this.chaser.crashed = true;
                // Explosion FX
                this.spawnParticles(this.chaser.x + this.chaser.width/2, this.chaser.y + this.chaser.height/2, '#ff4d00', 40);
                this.spawnParticles(this.chaser.x + this.chaser.width/2, this.chaser.y + this.chaser.height/2, '#000000', 20); // Smoke
            }
            
            if (this.chaser.crashed) {
                // Tumble behind
                this.chaser.x -= 10; 
                this.chaser.y += (Math.random() - 0.5) * 10;
            }

            // Transition Timer
            if (this.stoppedAtCliff) {
                 this.cliffWaitTimer++;
                 if (this.cliffWaitTimer > 180) { // 3 Seconds wait
                     this.manager.changeScene('transition_to_level3');
                 }
            }
        }

        // Particle Update
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        if (keys['Enter']) this.manager.changeScene('level3');
    }

    spawnObstacle() {
        let roadTop = 150;
        let roadBottom = GAME_HEIGHT - 50;
        let laneHeight = (roadBottom - roadTop) / 3; 
        let randomLane = Math.floor(Math.random() * 3);
        
        let type = Math.random() < 0.5 ? 'wall' : 'pothole';

        this.obstacles.push({
            x: GAME_WIDTH, 
            y: roadTop + (randomLane * laneHeight) + 10,
            width: 50, 
            height: laneHeight - 20, 
            type: type
        });
    }

    draw(ctx) {
        // Draw Sky
        ctx.fillStyle = '#050510'; // Darker Night Sky
        ctx.fillRect(0, 0, GAME_WIDTH, 150);

        // --- DRAW BACKGROUND BUILDINGS ---
        this.bgElements.forEach(bg => {
            if(bg.type === 'light') return; // Skip lights for now

            ctx.fillStyle = bg.color;
            ctx.fillRect(bg.x, bg.y, bg.width, bg.height);
            
            // Draw Windows
            bg.windows.forEach(win => {
                ctx.fillStyle = win.lit ? '#fdfd96' : '#222'; // Yellow if lit, dark if off
                ctx.fillRect(bg.x + win.x, bg.y + win.y, win.w, win.h);
            });
        });

        // --- DRAW ROAD ---
        // Road Logic: Draw from 0 to roadEndX (or Screen width if null)
        let drawLimit = this.roadEndX !== null ? this.roadEndX : GAME_WIDTH;
        
        // Road Base
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 150, drawLimit, GAME_HEIGHT - 150);
        
        // Cliff Void (If visible)
        if (drawLimit < GAME_WIDTH) {
             ctx.fillStyle = '#000022'; // Deep abyss color
             ctx.fillRect(drawLimit, 150, GAME_WIDTH - drawLimit, GAME_HEIGHT - 150);
        }

        // Draw Road Lines
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 150, drawLimit, GAME_HEIGHT - 150); // Clip lines to road
        ctx.clip();
        
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 20; i++) { // Increase count to cover full width
            let lx = this.roadOffset + (i * 100);
            if (lx < drawLimit) {
                 ctx.fillRect(lx, GAME_HEIGHT / 2 + 50, 60, 10);
            }
        }
        ctx.restore();
        
        // --- DRAW STREET LIGHTS & ILLUMINATION ---
        this.bgElements.forEach(bg => {
            if(bg.type === 'light') {
                // Pole
                ctx.fillStyle = '#555';
                ctx.fillRect(bg.x, bg.y, 5, bg.h);
                // Lamp Head
                ctx.fillStyle = '#ddd';
                ctx.fillRect(bg.x - 10, bg.y, 15, 5); // Overhang

                // Light Cone (Gradient)
                let grad = ctx.createRadialGradient(bg.x, 150, 5, bg.x, 150, 100);
                grad.addColorStop(0, 'rgba(255, 255, 200, 0.4)'); // Bright center
                grad.addColorStop(1, 'rgba(255, 255, 200, 0)');   // Fade out
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(bg.x - 10, bg.y + 5);
                ctx.lineTo(bg.x - 60, 150 + 100); // Cast light down to road
                ctx.lineTo(bg.x + 60, 150 + 100);
                ctx.fill();
            }
        });


        // --- DRAW CHASER ---
        if (!this.chaser.crashed || Math.random() > 0.1) { // Flicker if crashed
            ctx.fillStyle = this.chaser.color;
            ctx.fillRect(this.chaser.x, this.chaser.y, this.chaser.width, this.chaser.height);
            ctx.fillStyle = '#000'; 
            ctx.fillRect(this.chaser.x + 20, this.chaser.y + 5, 20, this.chaser.height - 10);
        }

        // --- DRAW PLAYER ---
        if (this.player.invincibleTimer === 0 || this.player.blinkRate % 10 < 5) {
            // Draw French Fry Peeking Out (Drawn FIRST so the car body covers the bottom half)
            if (images['player'] && images['player'].complete) {
                // Centered horizontally (25px offset), sticking out top (-15px offset)
                ctx.drawImage(images['player'], this.player.x + 25, this.player.y - 15, 30, 40);
            }

            ctx.fillStyle = this.player.color;
            ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
            // Detail lines
            ctx.fillStyle = '#000';
            ctx.fillRect(this.player.x + 10, this.player.y + this.player.height - 5, 20, 10);
            ctx.fillRect(this.player.x + this.player.width - 30, this.player.y + this.player.height - 5, 20, 10);
        }

        // --- DRAW OBSTACLES (Updated Styles) ---
        this.obstacles.forEach(obs => {
            if (obs.type === 'wall') {
                // Wall: Draw Enemy Sprite
                if (images['enemy'] && images['enemy'].complete) {
                    ctx.drawImage(images['enemy'], obs.x, obs.y, obs.width, obs.height);
                } else {
                    // Fallback: Bright Orange with Darker Orange detail
                    ctx.fillStyle = '#fb8500';
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.fillStyle = '#c15500';
                    ctx.fillRect(obs.x, obs.y, 10, obs.height); 
                }
            } else if (obs.type === 'pothole') {
                // Pothole: Black Void with Neon Cyan Rim
                
                // 1. Draw the Rim (Outline)
                ctx.fillStyle = 'white'; // Neon Cyan
                ctx.beginPath();
                ctx.ellipse(
                    obs.x + obs.width / 2, 
                    obs.y + obs.height / 2, 
                    (obs.width / 2) + 4, // Rim is slightly larger than hole
                    (obs.height / 3) + 4, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // 2. Draw the Hole (Center)
                ctx.fillStyle = '#000000'; // Pure Black
                ctx.beginPath();
                ctx.ellipse(
                    obs.x + obs.width / 2, 
                    obs.y + obs.height / 2, 
                    obs.width / 2, 
                    obs.height / 3, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
        });
        
        // Draw Particles
        this.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });

        // UI Text
        if (!this.levelComplete) {
            drawGTAText(ctx, `OBSTACLES: ${this.obstaclesAvoided} / ${this.goal}`, 20, 40, 24);
        } else {
             drawGTAText(ctx, `ESCAPED!`, 20, 40, 24);
        }
        drawGTAText(ctx, `HP: ${this.player.hp}`, 20, 70, 24);
    }

    checkCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y);
    }
}
class Level3 {
    constructor(manager) {
        this.manager = manager;

        this.gravity = 0.6; // Increased gravity for faster feel
        this.ropesTotal = 12; 
        this.currentRopeIndex = 0;
        this.grabRadius = 60; 
        
        this.cameraX = 0;

        this.ropes = [];
        for (let i = 0; i < this.ropesTotal; i++) {
            this.ropes.push({
                x: 400 + (i * 220), 
                y: 0, 
                length: 180, 
                angle: 0,
                offset: i * 1.5 
            });
        }
        
        // Final Platform location
        const lastRope = this.ropes[this.ropesTotal - 1];
        this.platform = {
            x: lastRope.x + 200, // Distance from last rope
            y: 400,
            width: 300,
            height: 40
        };

        this.player = {
            state: 'swinging',
            x: 0, y: 0,
            vx: 0, vy: 0,
            width: 60, height: 120, // Match Level 1 dimensions
            color: '#ffd60a',
            rotation: 0, // For visual effects
            hp: 3 // Start with 3 HP
        };
        
        this.victoryTimer = 0;
        this.particles = []; // Particle system
    }

    // Helper to create splatter effects (Yellow Potato Particles)
    spawnParticles(x, y, count) {
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 10, 
                vy: (Math.random() - 0.5) * 10, 
                life: 40, 
                color: '#FFD700', // French Fry Yellow
                size: Math.random() * 6 + 4 // Pixelated chunks
            });
        }
    }

    update() {
        if (keys['Enter']) this.manager.changeScene('end'); // Debug skip

        // FASTER ROPE SWING: Fixed time step ensures consistency
        // Using a global counter or Date.now() is fine, but since update() is now fixed 60hz,
        // we can just increment a local tick or use Date.now(). 
        // Existing code used Date.now() / 250. Let's keep it but ensure it feels right.
        let time = Date.now() / 500;
        this.ropes.forEach(rope => {
            rope.angle = Math.sin(time + rope.offset) * 0.9; // Slightly wider swing too (0.9)
        });

        if (this.player.state === 'swinging') {
            let currentRope = this.ropes[this.currentRopeIndex];
            
            // Player hanging at end of rope
            this.player.x = currentRope.x + Math.sin(currentRope.angle) * currentRope.length;
            this.player.y = currentRope.y + Math.cos(currentRope.angle) * currentRope.length;
            this.player.rotation = -currentRope.angle; // Rotate with rope

            if (keyPresses['Space']) {
                keyPresses['Space'] = false;
                this.player.state = 'flying';
                this.player.rotation = 0;
                
                let swingDir = Math.cos(time + currentRope.offset); 
                // Adjusted Launch Velocity to prevent overshooting
                this.player.vx = (11 * swingDir) + 2; 
                this.player.vy = -12; // Lower Jump
            }

        } else if (this.player.state === 'flying') {
            this.player.x += this.player.vx;
            this.player.y += this.player.vy;
            this.player.vy += this.gravity; 
            this.player.vx *= 0.98; // Increased Air resistance 

            // 1. Check for Next Rope
            let nextRopeIndex = this.currentRopeIndex + 1;
            if (nextRopeIndex < this.ropes.length) {
                let nextRope = this.ropes[nextRopeIndex];
                
                let tipX = nextRope.x + Math.sin(nextRope.angle) * nextRope.length;
                let tipY = nextRope.y + Math.cos(nextRope.angle) * nextRope.length;

                let dist = Math.sqrt(
                    Math.pow(this.player.x - tipX, 2) + 
                    Math.pow(this.player.y - tipY, 2)
                );

                if (dist < this.grabRadius) {
                    this.currentRopeIndex = nextRopeIndex;
                    this.player.state = 'swinging';
                    this.player.vx = 0;
                    this.player.vy = 0;
                }
            }
            
            // 2. Check for Landing on Platform (Victory Condition)
            if (this.player.x > this.platform.x && 
                this.player.x < this.platform.x + this.platform.width &&
                this.player.y + this.player.height > this.platform.y &&
                this.player.y < this.platform.y + this.platform.height &&
                this.player.vy > 0) 
            {
                 this.player.state = 'victory';
                 this.player.y = this.platform.y - this.player.height;
                 this.player.vy = 0;
            }
        } 
        else if (this.player.state === 'victory') {
            this.victoryTimer++;
            
            // Jump for joy!
            // Small hops: sin wave
            this.player.y = (this.platform.y - this.player.height) - Math.abs(Math.sin(this.victoryTimer * 0.2) * 40);
            
            // Spin/Rotate
            this.player.rotation += 0.2; 
            
            // After 3 seconds, go to End Screen
            if (this.victoryTimer > 180) {
                this.manager.changeScene('end');
            }
        }

        // --- PARTICLE UPDATE ---
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        let targetCameraX = this.player.x - 300;
        this.cameraX += (targetCameraX - this.cameraX) * 0.1;

        // Fall Logic
        if (this.player.y > GAME_HEIGHT + 100) {
            this.spawnParticles(this.player.x, GAME_HEIGHT, 20); // Visual FX at bottom
            this.player.hp--;
            
            if (this.player.hp <= 0) {
                this.manager.changeScene('game_over', 'level3');
            } else {
                // Respawn at current rope
                this.player.state = 'swinging';
                this.player.vx = 0;
                this.player.vy = 0;
                
                // Immediately snap camera back to rope so we don't feel disoriented
                let currentRope = this.ropes[this.currentRopeIndex];
                this.cameraX = currentRope.x - 300;
            }
        }
    }

    draw(ctx) {
        ctx.save(); 

        // Background
        if (images['level3Bg'] && images['level3Bg'].complete && images['level3Bg'].naturalWidth !== 0) {
            ctx.drawImage(images['level3Bg'], 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            ctx.fillStyle = '#10002b'; 
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Retro Buildings Fallback
            ctx.fillStyle = '#3c096c';
            for(let i=0; i<50; i++) {
                let bgX = (i * 150) - (this.cameraX * 0.5); 
                ctx.fillRect(bgX, GAME_HEIGHT - 200, 100, 200);
                ctx.fillStyle = '#5a189a'; 
                if(i % 2 === 0) ctx.fillRect(bgX + 20, GAME_HEIGHT - 150, 20, 20);
                ctx.fillStyle = '#3c096c'; 
            }
        }

        ctx.translate(-this.cameraX, 0);
        
        // --- DRAW PLATFORM ---
        ctx.fillStyle = '#3a0ca3';
        ctx.fillRect(this.platform.x, this.platform.y, this.platform.width, this.platform.height);
        ctx.fillStyle = '#4cc9f0'; // Neon highlight
        ctx.fillRect(this.platform.x, this.platform.y, this.platform.width, 5);

        // --- RETRO ROPES ---
        this.ropes.forEach((rope, index) => {
            let tipX = rope.x + Math.sin(rope.angle) * rope.length;
            let tipY = rope.y + Math.cos(rope.angle) * rope.length;

            const segments = 12; 
            const dx = (tipX - rope.x) / segments;
            const dy = (tipY - rope.y) / segments;

            ctx.fillStyle = '#e0aaff';
            for(let j = 0; j < segments; j++) {
                // Draw Rope Segments as Pixels
                ctx.fillRect(rope.x + (dx * j) - 3, rope.y + (dy * j) - 3, 6, 6);
            }

            // Rope Handle
            ctx.fillStyle = '#fff';
            ctx.fillRect(tipX - 5, tipY - 5, 10, 10);
            
            // Next Target Visual
            if (index === this.currentRopeIndex + 1) {
                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 2;
                // Square Box for Retro Feel
                ctx.strokeRect(tipX - this.grabRadius, tipY - this.grabRadius, this.grabRadius*2, this.grabRadius*2);
            }
        });

        // --- DRAW PLAYER ---
        // Save context for player rotation/transform
        ctx.save();
        
        // Pivot at center of player
        ctx.translate(this.player.x, this.player.y);
        ctx.rotate(this.player.rotation);
        
        if (images['player'] && images['player'].complete) {
            // Draw image centered on pivot
            // Note: In Level 1, we drew from top-left, but here we translated to center. 
            // We need to offset by half width/height
            ctx.drawImage(images['player'], -this.player.width/2, -this.player.height/2, this.player.width, this.player.height);
        } else {
            // Fallback
            ctx.fillStyle = this.player.color;
            ctx.fillRect(-this.player.width/2, -this.player.height/2, this.player.width, this.player.height);
            ctx.fillStyle = 'red';
            ctx.fillRect(-this.player.width/2, -this.player.height/2 + 5, this.player.width, 5); // Headband
        }
        
        ctx.restore(); // Restore player transform

        // --- DRAW PARTICLES ---
        this.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });

        ctx.restore(); // Restore camera transform

        // UI: Rope Counter
        ctx.fillStyle = 'white';
        ctx.font = '20px "Courier New", monospace'; 
        ctx.fillText(`ROPE: ${this.currentRopeIndex + 1} / ${this.ropesTotal}`, 20, 30);
        
        // UI: HP Display (Consistent with other levels)
        ctx.fillText(`HP:`, 20, 60);
        for(let i = 0; i < 3; i++) { // Max 3 HP here
            ctx.fillStyle = i < this.player.hp ? 'lime' : 'gray';
            ctx.fillRect(60 + (i * 25), 45, 20, 15);
        }
    }
}


/**
 * END SCREEN
 */
class EndScreen {
    constructor(manager) { this.manager = manager; }
    update() {}
    draw(ctx) {
        // 1. Draw Background
        if (images['ending'] && images['ending'].complete && images['ending'].naturalWidth !== 0) {
             ctx.drawImage(images['ending'], 0, 0, GAME_WIDTH, GAME_HEIGHT);
        } else {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        // 2. GTA Style "YOU WON" Text
        ctx.save();
        ctx.textAlign = 'center';
        
        // "Impact" is the closest standard web font to the GTA style heavy font
        ctx.font = "italic 100px Impact, sans-serif"; 
        
        // Black Outline
        ctx.lineWidth = 8;
        ctx.strokeStyle = 'black';
        ctx.strokeText("YOU WON", GAME_WIDTH / 2, GAME_HEIGHT / 2);
        
        // Golden Fill (Mission Passed style)
        ctx.fillStyle = '#bfa55a'; 
        ctx.fillText("YOU WON", GAME_WIDTH / 2, GAME_HEIGHT / 2);
        
        ctx.restore();
    }
}

/**
 * MAIN INIT
 */
const game = new SceneManager();

// FIXED TIME STEP LOOP (60 FPS)
let lastTime = 0;
const targetFPS = 60;
const timeStep = 1000 / targetFPS;
let accumulator = 0;

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    accumulator += deltaTime;

    // Run update logic in fixed time steps
    while (accumulator >= timeStep) {
        game.update();
        accumulator -= timeStep;
    }

    // Draw as fast as possible (interpolating would be better but this is sufficient for pixel art style)
    game.draw(ctx);
    
    requestAnimationFrame(gameLoop);
}

loadAssets(() => {
    console.log("Assets loaded. Starting Game Loop.");
    requestAnimationFrame(gameLoop);
});

</script>
</body>
</html>